export declare class Formatter {
    /**
     * Dictates what sort of line endings to use.
     */
    get jsonEolStyle(): EolStyle;
    set jsonEolStyle(value: EolStyle);
    /**
     * Maximum length of a complex element on a single line.  This includes only the data for the inlined element,
     * not indentation or leading property names.
     */
    get maxInlineLength(): number;
    set maxInlineLength(value: number);
    /**
     * Maximum nesting level that can be displayed on a single line.  A primitive type or an empty
     * array or object has a complexity of 0.  An object or array has a complexity of 1 greater than
     * its most complex child.
     */
    get maxInlineComplexity(): number;
    set maxInlineComplexity(value: number);
    /**
     * Maximum nesting level that can be arranged spanning multiple lines, with multiple items per line.
     */
    get maxCompactArrayComplexity(): number;
    set maxCompactArrayComplexity(value: number);
    /**
     * If an inlined array or object contains other arrays or objects, setting NestedBracketPadding to true
     * will include spaces inside the outer brackets.  (See also simpleBracketPadding)
     */
    get nestedBracketPadding(): boolean;
    set nestedBracketPadding(value: boolean);
    /**
     * If an inlined array or object does NOT contain other arrays/objects, setting SimpleBracketPadding to true
     * will include spaces inside the brackets.  (See also nestedBracketPadding)
     */
    get simpleBracketPadding(): boolean;
    set simpleBracketPadding(value: boolean);
    /**
     * If true, includes a space after property colons.
     */
    get colonPadding(): boolean;
    set colonPadding(value: boolean);
    /**
     * If true, includes a space after commas separating array items and object properties.
     */
    get commaPadding(): boolean;
    set commaPadding(value: boolean);
    /**
     * Depth at which lists/objects are always fully expanded, regardless of other settings.
     * -1 = none; 0 = root node only; 1 = root node and its children.
     */
    get alwaysExpandDepth(): number;
    set alwaysExpandDepth(value: number);
    /**
     * Number of spaces to use per indent level (unless UseTabToIndent is true)
     */
    get indentSpaces(): number;
    set indentSpaces(value: number);
    /**
     * Uses a single tab per indent level, instead of spaces.
     */
    get useTabToIndent(): boolean;
    set useTabToIndent(value: boolean);
    /**
     * Value from 0 to 100 indicating how similar collections of inline objects need to be to be formatted as
     * a table.  A group of objects that don't have any property names in common has a similarity of zero.  A
     * group of objects that all contain the exact same property names has a similarity of 100.  Setting this
     * to a value &gt;100 disables table formatting with objects as rows.
     */
    get tableObjectMinimumSimilarity(): number;
    set tableObjectMinimumSimilarity(value: number);
    /**
     * Value from 0 to 100 indicating how similar collections of inline arrays need to be to be formatted as
     * a table.  Similarity for arrays refers to how similar they are in length; if they all have the same
     * length their similarity is 100.  Setting this to a value &gt;100 disables table formatting with arrays as
     * rows.
     */
    get tableArrayMinimumSimilarity(): number;
    set tableArrayMinimumSimilarity(value: number);
    /**
     * If true, property names of expanded objects are padded to the same size.
     */
    get alignExpandedPropertyNames(): boolean;
    set alignExpandedPropertyNames(value: boolean);
    /**
     * If true, numbers won't be right-aligned with matching precision.
     */
    get dontJustifyNumbers(): boolean;
    set dontJustifyNumbers(value: boolean);
    /**
     * String attached to the beginning of every line, before regular indentation.
     */
    get prefixString(): string;
    set prefixString(value: string);
    /**
     * Function that returns the visual width of strings measured in characters.  This is used to line
     * columns up when formatting objects/arrays as tables.  You can use the static methods
     * StringWidthByCharacterCount, StringWidthWithEastAsian, or supply your own.
     */
    get stringWidthFunc(): (s: string) => number;
    set stringWidthFunc(value: (s: string) => number);
    /**
     * Returns a JSON-formatted string that represents the given JavaScript value.
     * @param jsValue
     */
    serialize(jsValue: any): string;
    /**
     * Returns the character count of the string (just like the String.length property).
     * See StringWidthFunc
     */
    static StringWidthByCharacterCount(str: string): number;
    /**
     * Returns a width, where some East Asian symbols are treated as twice as wide as Latin symbols.
     * See StringWidthFunc
     */
    static StringWidthWithEastAsian(str: string): number;
    private _jsonEolStyle;
    private _maxInlineLength;
    private _maxInlineComplexity;
    private _maxCompactArrayComplexity;
    private _nestedBracketPadding;
    private _simpleBracketPadding;
    private _colonPadding;
    private _commaPadding;
    private _alwaysExpandDepth;
    private _indentSpaces;
    private _useTabToIndent;
    private _tableObjectMinimumSimilarity;
    private _tableArrayMinimumSimilarity;
    private _alignExpandedPropertyNames;
    private _dontJustifyNumbers;
    private _prefixString;
    private _stringWidthFunc;
    private _eolStr;
    private _indentStr;
    private _paddedCommaStr;
    private _paddedColonStr;
    private _indentCache;
    /**
     * Set up some intermediate fields for efficiency.
     * @private
     */
    private initInternals;
    private indent;
    private combine;
    /**
     * Base of recursion.  Nearly everything comes through here.
     * @param depth
     * @param element
     * @private
     */
    private formatElement;
    /**
     * Formats a JSON element other than an array or object.
     * @param depth
     * @param element
     * @private
     */
    private formatSimple;
    private formatArray;
    private formatObject;
    private emptyArray;
    /**
     * Try to format this array in a single line, if possible.
     * @param thisItem
     * @private
     */
    private formatArrayInline;
    /**
     * Try to format this array, spanning multiple lines, but with several items per line, if possible.
     * @param thisItem
     * @private
     */
    private formatArrayMultilineCompact;
    /**
     * Format this array with one child object per line, and those objects padded to line up nicely.
     * @param thisItem
     * @private
     */
    private formatTableArrayObject;
    /**
     * Format this array with one child array per line, and those arrays padded to line up nicely.
     * @param thisItem
     * @private
     */
    private formatTableArrayArray;
    /**
     * Format this array in a single line, with padding to line up with siblings.
     * @param thisItem
     * @param columnStatsArray
     * @private
     */
    private formatArrayTableRow;
    /**
     * Write this array with each element starting on its own line.  (They might be multiple lines themselves.)
     * @param thisItem
     * @private
     */
    private formatArrayExpanded;
    private emptyObject;
    /**
     * Format this object as a single line, if possible.
     * @param thisItem
     * @private
     */
    private formatObjectInline;
    /**
     * Format this object with one child object per line, and those objects padded to line up nicely.
     * @param thisItem
     * @private
     */
    private formatTableObjectObject;
    /**
     * Format this object with one child array per line, and those arrays padded to line up nicely.
     * @param thisItem
     * @private
     */
    private formatTableObjectArray;
    /**
     * Format this object in a single line, with padding to line up with siblings.
     * @param thisItem
     * @param columnStatsArray
     * @private
     */
    private formatObjectTableRow;
    /**
     * Write this object with each element starting on its own line.  (They might be multiple lines
     * themselves.)
     * @param thisItem
     * @param forceExpandPropNames
     * @private
     */
    private formatObjectExpanded;
    /**
     * If the given nodes are all numbers and not too big or small, format them to the same precision and width.
     * @param itemList
     * @private
     */
    private justifyParallelNumbers;
    /**
     * Check if this node's object children can be formatted as a table, and if so, return stats about
     * their properties, such as max width.  Returns null if they're not eligible.
     * @param thisItem
     * @private
     */
    private getPropertyStats;
    /**
     * Check if this node's array children can be formatted as a table, and if so, gather stats like max width.
     * Returns null if they're not eligible.
     * @param thisItem
     * @private
     */
    private getArrayStats;
}
export declare enum EolStyle {
    Crlf = 0,
    lf = 1
}
